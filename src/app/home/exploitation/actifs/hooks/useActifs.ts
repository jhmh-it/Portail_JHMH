'use client';

import { useQuery, type QueryClient } from '@tanstack/react-query';

import type { Actif, ActifsFilters } from '../types';

/**
 * Clés de requête pour TanStack Query
 */
export const actifsQueryKeys = {
  /** Clé pour la liste des actifs avec filtres */
  listings: (filters?: ActifsFilters) =>
    ['actifs', 'listings', filters] as const,
  /** Clé pour tous les actifs */
  all: () => ['actifs'] as const,
} as const;

/**
 * Interface de retour du hook useActifs
 */
export interface UseActifsReturn {
  /** Liste des actifs */
  actifs: Actif[];
  /** Indicateur de chargement */
  isLoading: boolean;
  /** Message d'erreur si présent */
  error: Error | null;
  /** Fonction pour rafraîchir les données */
  refetch: () => Promise<void>;
  /** Indicateur de succès */
  isSuccess: boolean;
  /** Indicateur d'erreur */
  isError: boolean;
}

/**
 * Construit les paramètres de requête pour l'API
 */
function buildQueryParams(filters?: ActifsFilters): URLSearchParams {
  const params = new URLSearchParams();

  if (!filters) return params;

  Object.entries(filters).forEach(([key, value]) => {
    if (value !== undefined && value !== null && value !== '') {
      params.append(key, String(value));
    }
  });

  return params;
}

/**
 * Appelle l'API Next.js pour récupérer les actifs
 */
async function fetchActifsFromAPI(filters?: ActifsFilters): Promise<Actif[]> {
  const params = buildQueryParams(filters);
  const queryString = params.toString();
  const url = `/api/actifs-listings${queryString ? `?${queryString}` : ''}`;

  const response = await fetch(url, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
    },
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({
      error: `HTTP error! status: ${response.status}`,
    }));
    throw new Error(
      errorData.error ?? `HTTP error! status: ${response.status}`
    );
  }

  const result: Actif[] = await response.json();
  return result;
}

/**
 * Hook pour récupérer les actifs listings
 * Utilise TanStack Query pour le cache et la gestion d'état
 * Maintenant connecté via API route Next.js
 */
export function useActifs(filters?: ActifsFilters): UseActifsReturn {
  const { data, isLoading, error, refetch, isSuccess, isError } = useQuery({
    queryKey: actifsQueryKeys.listings(filters),
    queryFn: () => fetchActifsFromAPI(filters),
    staleTime: 15 * 60 * 1000, // 15 minutes (les actifs changent rarement)
    gcTime: 30 * 60 * 1000, // 30 minutes
    retry: 3,
    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
  });

  return {
    actifs: data ?? [],
    isLoading,
    error,
    refetch: async () => {
      await refetch();
    },
    isSuccess,
    isError,
  };
}

/**
 * Récupère la liste simple des actifs pour les dropdowns depuis /api/actifs
 * Cette route proxifie l'endpoint JHMH /api/assets/actifs
 */
async function fetchSimpleActifsFromAPI(): Promise<Actif[]> {
  const url = `/api/actifs`;

  const response = await fetch(url, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
    },
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({
      error: `HTTP error! status: ${response.status}`,
    }));
    throw new Error(
      errorData.error ?? `HTTP error! status: ${response.status}`
    );
  }

  const payload = await response.json();
  // La route /api/actifs retourne un objet { success, data } → on l'extrait
  if (payload && Array.isArray(payload.data)) {
    return payload.data as Actif[];
  }
  // Par robustesse, si jamais elle retourne directement un tableau
  if (Array.isArray(payload)) {
    return payload as Actif[];
  }
  return [];
}

/**
 * Hook pour récupérer la liste simple des actifs (dropdown)
 * À utiliser dans les écrans qui nécessitent uniquement une sélection d'actif
 */
export function useSimpleActifs(): UseActifsReturn {
  const { data, isLoading, error, refetch, isSuccess, isError } = useQuery({
    queryKey: actifsQueryKeys.all(),
    queryFn: () => fetchSimpleActifsFromAPI(),
    staleTime: 15 * 60 * 1000,
    gcTime: 30 * 60 * 1000,
    retry: 3,
    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
  });

  return {
    actifs: data ?? [],
    isLoading,
    error: (error as Error) ?? null,
    refetch: async () => {
      await refetch();
    },
    isSuccess,
    isError,
  };
}

/**
 * Fonction utilitaire pour précharger les actifs
 * À utiliser dans les Server Components ou lors de la navigation
 */
export async function prefetchActifs(
  queryClient: QueryClient,
  filters?: ActifsFilters
): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: actifsQueryKeys.listings(filters),
    queryFn: () => fetchActifsFromAPI(filters),
    staleTime: 15 * 60 * 1000,
  });
}

/**
 * Fonction utilitaire pour invalider le cache des actifs
 * À utiliser après des modifications
 */
export async function invalidateActifs(
  queryClient: QueryClient
): Promise<void> {
  await queryClient.invalidateQueries({
    queryKey: actifsQueryKeys.all(),
  });
}

// Types historiques pour compatibilité (DEPRECATED)
/** @deprecated Utiliser ActifListing à la place */
import type { ActifListing } from '../types/actifs';

export type JhmhActif = ActifListing;
