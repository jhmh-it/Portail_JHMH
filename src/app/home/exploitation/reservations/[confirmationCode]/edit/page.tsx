/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/prefer-nullish-coalescing, react-hooks/exhaustive-deps, no-nested-ternary, react/no-unescaped-entities, @typescript-eslint/prefer-optional-chain */
'use client';

import { zodResolver } from '@hookform/resolvers/zod';
import { ArrowLeft, Save, Loader2, History } from 'lucide-react';
import { useParams, useRouter } from 'next/navigation';
import React from 'react';
import { useForm, type FieldErrors } from 'react-hook-form';
import { toast } from 'sonner';
import { z } from 'zod';

import { DashboardLayout } from '@/components/dashboard/dashboard-layout';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useToastStore } from '@/stores/toast-store';

import { HistoryTimeline } from '../../components/HistoryTimeline';
import {
  useReservationDetails,
  useReservationFields,
  useReservationHistory,
  useReservationOverrides,
  useDeleteOverride,
} from '../../hooks';

// Type du formulaire (reuse central type for consistency)
type ReservationOverrideFormData = Record<string, string | number | undefined>;

export default function EditReservationPage() {
  const params = useParams();
  const router = useRouter();
  const confirmationCode = params.confirmationCode as string;

  const breadcrumbs = [
    { label: 'Accueil', href: '/home' },
    { label: 'Exploitation', href: '/home/exploitation' },
    { label: 'R√©servations', href: '/home/exploitation/reservations' },
    {
      label: confirmationCode,
      href: `/home/exploitation/reservations/${confirmationCode}`,
    },
    { label: 'Modifier', href: '#' },
  ];

  // Store pour les toasts
  const {
    showReservationLoading,
    showReservationSuccess,
    showReservationError,
    showReservationInfo,
    dismissToast: _dismissToast,
  } = useToastStore();

  // √âtat pour g√©rer l'historique et la mise en √©vidence
  const [isHistoryOpen, setIsHistoryOpen] = React.useState(false);
  const [highlightedFields, setHighlightedFields] = React.useState<string[]>(
    []
  );
  const [selectedDate, setSelectedDate] = React.useState<string>('');

  // √âtat pour g√©rer la suppression d'override
  const [_deleteModalOpen, setDeleteModalOpen] = React.useState(false);
  const [fieldToDelete, setFieldToDelete] = React.useState<{
    fieldName: string;
    displayName: string;
    overriddenValue: string;
  } | null>(null);

  // Hooks pour les donn√©es
  const { reservation, isLoading: isLoadingReservation } =
    useReservationDetails({
      confirmationCode,
    });
  const {
    data: fieldsData,
    isLoading: isLoadingFields,
    error: fieldsError,
  } = useReservationFields();
  const { data: historyData, isLoading: isLoadingHistory } =
    useReservationHistory(confirmationCode);

  // Hook pour soumettre les surcharges
  const {
    submitOverrides,
    isSubmitting,
    error: submissionError,
    data: submissionData,
  } = useReservationOverrides(confirmationCode);

  // Hook pour supprimer les overrides
  const {
    deleteOverride,
    isDeleting,
    error: deleteError,
    data: deleteData,
  } = useDeleteOverride(confirmationCode);

  // Effet pour rediriger apr√®s succ√®s
  React.useEffect(() => {
    // V√©rifier si on doit rediriger (apr√®s succ√®s)
    // On peut ajouter une logique plus sophistiqu√©e ici si n√©cessaire
  }, []);

  // Effet pour g√©rer les toasts et la redirection apr√®s soumission
  React.useEffect(() => {
    if (submissionData) {
      // Fermer tous les toasts de loading avec un d√©lai pour √™tre s√ªr
      setTimeout(() => {
        toast.dismiss();

        if (submissionData.success) {
          console.warn('‚úÖ Soumission r√©ussie:', submissionData);

          showReservationSuccess(
            'Modifications sauvegard√©es avec succ√®s !',
            'Redirection vers la page de d√©tails dans 2 secondes...'
          );

          // Redirection automatique apr√®s un court d√©lai
          setTimeout(() => {
            router.push(`/home/exploitation/reservations/${confirmationCode}`);
          }, 2000);
        } else {
          showReservationError(
            'Sauvegarde termin√©e avec des avertissements',
            "Certaines modifications n'ont pas pu √™tre appliqu√©es"
          );
        }
      }, 100); // Petit d√©lai pour s'assurer que toast.dismiss() fonctionne
    }

    if (submissionError) {
      // Fermer tous les toasts de loading avec un d√©lai
      setTimeout(() => {
        toast.dismiss();

        console.error('‚ùå Erreur de soumission:', submissionError);

        showReservationError(
          '√âchec de la sauvegarde',
          submissionError.message ||
            'Une erreur technique est survenue. Veuillez r√©essayer.'
        );
      }, 100);
    }
  }, [
    submissionData,
    submissionError,
    router,
    confirmationCode,
    showReservationSuccess,
    showReservationError,
  ]);

  // Fonction pour g√©rer la soumission
  const handleFormSubmit = (data: ReservationOverrideFormData) => {
    onSubmit(data);
  };

  // Fonction pour g√©rer les erreurs de validation
  const handleFormError = (
    errors: FieldErrors<ReservationOverrideFormData>
  ) => {
    console.error('‚ùå Erreurs de validation:', errors);

    const errorCount = Object.keys(errors).length;
    const firstError = Object.values(errors)[0];

    showReservationError(
      'Erreur de validation',
      `${errorCount} champ${errorCount > 1 ? 's' : ''} ${errorCount > 1 ? 'contiennent' : 'contient'} des erreurs. ${firstError?.message ?? 'Veuillez corriger les erreurs.'}`
    );
  };

  // Cr√©er le sch√©ma de validation dynamique
  const validationSchema = React.useMemo(() => {
    if (!fieldsData?.data) return z.object({});

    const schemaFields: Record<string, z.ZodTypeAny> = {};

    fieldsData.data.forEach((field: { fieldName: string; type: string }) => {
      switch (field.fieldName) {
        // Validation stricte pour l'email
        case 'guest_email':
          schemaFields[field.fieldName] = z
            .string()
            .email('Format email invalide')
            .optional()
            .or(z.literal(''));
          break;

        // Validation stricte pour le t√©l√©phone
        case 'guest_phone':
          schemaFields[field.fieldName] = z
            .string()
            .regex(
              /^[+]?[\d\s\-().]{10,}$/,
              'Format t√©l√©phone invalide (minimum 10 chiffres)'
            )
            .optional()
            .or(z.literal(''));
          break;

        // Validation stricte pour les nombres de personnes (entiers positifs)
        case 'number_of_guests':
        case 'adults':
        case 'children':
        case 'infants':
          schemaFields[field.fieldName] = z
            .union([z.string(), z.number()])
            .transform(val =>
              val === '' || val === undefined ? undefined : Number(val)
            )
            .refine(
              val => val === undefined || (Number.isInteger(val) && val >= 0),
              {
                message: 'Doit √™tre un nombre entier positif',
              }
            )
            .optional();
          break;

        // Validation pour les autres champs selon leur type
        default:
          switch (field.type) {
            case 'string':
              // Exclure les champs de notes et commentaires
              if (
                !field.fieldName.includes('note') &&
                !field.fieldName.includes('audit')
              ) {
                schemaFields[field.fieldName] = z
                  .string()
                  .min(1, 'Ce champ ne peut pas √™tre vide')
                  .optional()
                  .or(z.literal(''));
              }
              break;
            case 'integer':
              schemaFields[field.fieldName] = z
                .union([z.string(), z.number()])
                .transform(val =>
                  val === '' || val === undefined ? undefined : Number(val)
                )
                .refine(
                  val =>
                    val === undefined || (Number.isInteger(val) && val >= 0),
                  {
                    message: 'Doit √™tre un nombre entier positif',
                  }
                )
                .optional();
              break;
            case 'number':
              schemaFields[field.fieldName] = z
                .union([z.string(), z.number()])
                .transform(val =>
                  val === '' || val === undefined ? undefined : Number(val)
                )
                .refine(val => val === undefined || (!isNaN(val) && val >= 0), {
                  message: 'Doit √™tre un nombre positif',
                })
                .optional();
              break;
          }
          break;
      }
    });

    return z.object(schemaFields);
  }, [fieldsData]);

  // Initialiser le formulaire
  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
    getValues: _getValues,
  } = useForm<ReservationOverrideFormData>({
    resolver: zodResolver(validationSchema),
  });

  // Grouper les champs par cat√©gorie
  const groupedFields = React.useMemo(() => {
    if (!fieldsData?.data) return {};

    // Filtrer les champs pour exclure les notes et commentaires
    const filteredFields = fieldsData.data.filter(
      field =>
        !field.fieldName.includes('note') &&
        !field.fieldName.includes('audit') &&
        !field.displayName.toLowerCase().includes('note') &&
        !field.displayName.toLowerCase().includes('audit')
    );

    return filteredFields.reduce(
      (
        groups: Record<string, typeof filteredFields>,
        field: (typeof filteredFields)[number]
      ) => {
        // Grouper les champs par cat√©gorie
        let category = 'Informations g√©n√©rales';

        if (field.fieldName.includes('guest_')) {
          category = 'Informations client';
        } else if (
          field.fieldName.includes('accommodation_') ||
          field.fieldName.includes('cleaning_') ||
          field.fieldName.includes('_ht') ||
          field.fieldName.includes('_ttc') ||
          field.fieldName.includes('_vat') ||
          field.fieldName.includes('city_tax') ||
          field.fieldName.includes('deposit_')
        ) {
          category = 'Informations financi√®res';
        } else if (
          field.fieldName.includes('adults') ||
          field.fieldName.includes('children') ||
          field.fieldName.includes('infants') ||
          field.fieldName.includes('number_of_guests')
        ) {
          category = 'Composition du s√©jour';
        }

        if (!groups[category]) {
          groups[category] = [];
        }
        groups[category].push(field);
        return groups;
      },
      {} as Record<string, typeof filteredFields>
    );
  }, [fieldsData]);

  // Mapping des noms de champs entre l'API des champs et les donn√©es de r√©servation
  const fieldMapping: Record<string, string | string[]> = {
    guest_name: ['GUEST_NAME', 'guest_name'],
    guest_email: ['GUEST_EMAIL', 'guest_email'],
    guest_phone: ['guest_phone', 'GUEST_PHONE'],
    number_of_guests: ['NUMBER_OF_GUESTS', 'number_of_guests'],
    adults: ['NUMBER_GUEST_ADULT', 'adults'],
    children: ['NUMBER_GUEST_CHILD', 'children'],
    infants: ['NUMBER_GUEST_INFANT', 'infants'],
    accommodation_ht: ['ACCOMODATION_HT', 'accommodation_ht'],
    accommodation_vat: ['ACCOMODATION_VAT', 'accommodation_vat'],
    accommodation_ttc: ['ACCOMODATION_TTC', 'accommodation_ttc'],
    cleaning_ht: ['MANDATORY_CLEANING_HT', 'cleaning_ht'],
    cleaning_vat: ['MANDATORY_CLEANING_VAT', 'cleaning_vat'],
    cleaning_ttc: ['MANDATORY_CLEANING_TTC', 'cleaning_ttc'],
    extra_cleaning_ht: ['EXTRA_CLEANING_HT', 'extra_cleaning_ht'],
    extra_cleaning_vat: ['EXTRA_CLEANING_VAT', 'extra_cleaning_vat'],
    extra_cleaning_ttc: ['EXTRA_CLEANING_TTC', 'extra_cleaning_ttc'],
    room_update_ht: ['ADD_CHARGE_ROOM_UPDATE_HT', 'room_update_ht'],
    room_update_vat: ['ADD_CHARGE_ROOM_UPDATE_VAT', 'room_update_vat'],
    room_update_ttc: ['ADD_CHARGE_ROOM_UPDATE_TTC', 'room_update_ttc'],
    early_checkin_ht: ['EARLY_CI_HT', 'early_checkin_ht'],
    early_checkin_vat: ['EARLY_CI_VAT', 'early_checkin_vat'],
    early_checkin_ttc: ['EARLY_CI_TTC', 'early_checkin_ttc'],
    late_checkout_ht: ['LATE_CO_HT', 'late_checkout_ht'],
    late_checkout_vat: ['LATE_CO_VAT', 'late_checkout_vat'],
    late_checkout_ttc: ['LATE_CO_TTC', 'late_checkout_ttc'],
    laundry_ht: ['LAUNDRY_HT', 'laundry_ht'],
    laundry_vat: ['LAUNDRY_VAT', 'laundry_vat'],
    laundry_ttc: ['LAUNDRY_TTC', 'laundry_ttc'],
    food_ht: ['FOOD_HT', 'food_ht'],
    food_vat: ['FOOD_VAT', 'food_vat'],
    food_ttc: ['FOOD_TTC', 'food_ttc'],
    city_tax: ['CITY_TAX', 'city_tax'],
    deposit_withdraw: ['DEPOSIT_WITHDRAW', 'deposit_withdraw'],
    audit_note: ['auditNote', 'audit_note'],
  };

  // Fonction pour r√©cup√©rer la valeur d'un champ avec le mapping
  const getFieldValue = (fieldName: string, reservationData: any): any => {
    const mappings = fieldMapping[fieldName];

    if (!mappings) {
      // Si pas de mapping, essayer le nom direct
      const value = reservationData[fieldName];
      return value !== null ? value : undefined;
    }

    const mappingArray = Array.isArray(mappings) ? mappings : [mappings];

    for (const mapping of mappingArray) {
      const value = reservationData[mapping];
      if (value !== undefined && value !== null) {
        return value;
      }
    }

    // Si aucune valeur trouv√©e, retourner null/undefined comme undefined pour ne pas pr√©-remplir
    return undefined;
  };

  // Fonction pour formater les valeurs num√©riques (arrondir √† 2 d√©cimales max)
  const formatValueForField = (value: any, fieldType: string): any => {
    if (value === undefined || value === null) return undefined;

    // Convertir en nombre si c'est une string
    const numValue = typeof value === 'string' ? parseFloat(value) : value;

    // Pour les champs num√©riques, arrondir √† 2 d√©cimales
    if (
      fieldType === 'number' &&
      typeof numValue === 'number' &&
      !isNaN(numValue)
    ) {
      // Arrondir √† 2 d√©cimales et supprimer les z√©ros inutiles
      const rounded = Math.round(numValue * 100) / 100;
      return rounded;
    }

    // Pour les entiers, s'assurer qu'il n'y a pas de d√©cimales
    if (
      fieldType === 'integer' &&
      typeof numValue === 'number' &&
      !isNaN(numValue)
    ) {
      return Math.round(numValue);
    }

    return value;
  };

  // Fonction pour formater une valeur pour l'affichage dans l'input
  const formatValueForDisplay = (value: any, fieldType: string): string => {
    const formatted = formatValueForField(value, fieldType);
    return formatted !== undefined ? String(formatted) : '';
  };

  // Fonctions helper pour les inputs
  const getInputType = (field: { fieldName: string; type: string }): string => {
    switch (field.fieldName) {
      case 'guest_email':
        return 'email';
      case 'guest_phone':
        return 'tel';
      default:
        return field.type === 'string' ? 'text' : 'number';
    }
  };

  const getInputPattern = (field: {
    fieldName: string;
  }): string | undefined => {
    switch (field.fieldName) {
      case 'guest_phone':
        return '[+]?[0-9\\s\\-().]{10,}';
      case 'number_of_guests':
      case 'adults':
      case 'children':
      case 'infants':
        return '[0-9]*';
      default:
        return undefined;
    }
  };

  const getInputMode = (field: { fieldName: string; type: string }): string => {
    switch (field.fieldName) {
      case 'guest_email':
        return 'email';
      case 'guest_phone':
        return 'tel';
      case 'number_of_guests':
      case 'adults':
      case 'children':
      case 'infants':
        return 'numeric';
      default:
        return field.type !== 'string' ? 'decimal' : 'text';
    }
  };

  const getPlaceholder = (field: {
    fieldName: string;
    displayName: string;
  }): string => {
    switch (field.fieldName) {
      case 'guest_email':
        return 'exemple@email.com';
      case 'guest_phone':
        return '+33 1 23 45 67 89';
      case 'number_of_guests':
        return 'Ex: 2';
      case 'adults':
        return 'Ex: 2';
      case 'children':
        return 'Ex: 1';
      case 'infants':
        return 'Ex: 0';
      default:
        return `Entrez ${field.displayName.toLowerCase()}`;
    }
  };

  // Pr√©-remplir le formulaire avec les donn√©es de la r√©servation
  React.useEffect(() => {
    if (reservation && fieldsData?.data) {
      const initialData: ReservationOverrideFormData = {};

      console.warn('Donn√©es de r√©servation pour pr√©-remplissage:', reservation);
      console.warn(
        'Cl√©s disponibles dans les donn√©es de r√©servation:',
        Object.keys(reservation)
      );

      fieldsData.data.forEach(field => {
        const rawValue = getFieldValue(field.fieldName, reservation);
        const value = formatValueForField(rawValue, field.type);

        if (value !== undefined && value !== null) {
          initialData[field.fieldName] = value;
          console.warn(
            `‚úÖ Champ ${field.fieldName} pr√©-rempli avec:`,
            value,
            `(original: ${rawValue})`
          );
        } else {
          console.warn(
            `‚ùå Champ ${field.fieldName} non trouv√© dans les donn√©es`
          );

          // V√©rifier s'il y a une valeur null (champ existe mais vide)
          const mappings = fieldMapping[field.fieldName];
          if (mappings) {
            const mappingArray = Array.isArray(mappings)
              ? mappings
              : [mappings];
            for (const mapping of mappingArray) {
              const rawValue = reservation[mapping];
              if (rawValue === null) {
                console.warn(
                  `üîç Champ ${field.fieldName} trouv√© mais valeur null dans ${mapping}`
                );
                break;
              }
            }
          }

          // Essayons de voir s'il y a une cl√© similaire
          const similarKeys = Object.keys(reservation).filter(
            key =>
              key.toLowerCase().includes(field.fieldName.toLowerCase()) ||
              field.fieldName.toLowerCase().includes(key.toLowerCase())
          );
          if (similarKeys.length > 0) {
            console.warn(`üîç Cl√©s similaires trouv√©es:`, similarKeys);
          }
        }
      });

      console.warn('Donn√©es initiales du formulaire:', initialData);
      reset(initialData);
    }
  }, [reservation, fieldsData, reset]);

  // Force le re-rendu si les donn√©es ne sont pas encore disponibles
  React.useEffect(() => {
    if (reservation && fieldsData?.data) {
      const initialData: ReservationOverrideFormData = {};

      fieldsData.data.forEach(field => {
        const rawValue = getFieldValue(field.fieldName, reservation);
        const value = formatValueForField(rawValue, field.type);
        if (value !== undefined && value !== null) {
          initialData[field.fieldName] = value;
        }
      });

      reset(initialData);

      // Forcer le reformatage des champs apr√®s un court d√©lai
      setTimeout(() => {
        fieldsData.data.forEach(field => {
          if (field.type === 'number' || field.type === 'integer') {
            const input = document.getElementById(
              field.fieldName
            ) as HTMLInputElement;
            if (input && input.value) {
              const formattedValue = formatValueForDisplay(
                input.value,
                field.type
              );
              if (formattedValue !== input.value) {
                input.value = formattedValue;
                // D√©clencher l'√©v√©nement pour que React Hook Form soit au courant
                input.dispatchEvent(new Event('input', { bubbles: true }));
              }
            }
          }
        });
      }, 100);
    }
  }, [reservation, fieldsData, reset]);

  const onSubmit = React.useCallback(
    (data: ReservationOverrideFormData) => {
      console.warn('üöÄ onSubmit appel√© avec:', data);

      // Filtrer les valeurs vides et undefined, et pr√©parer les surcharges
      const overrides = Object.entries(data)
        .filter(
          ([_, value]) => value !== undefined && value !== '' && value !== null
        )
        .map(([fieldName, value]) => ({
          fieldName,
          overriddenValue: value as string | number,
        }));

      if (overrides.length === 0) {
        showReservationInfo(
          'Aucune modification d√©tect√©e',
          'Veuillez modifier au moins un champ avant de soumettre le formulaire'
        );
        return;
      }

      console.warn('üì§ Surcharges √† soumettre:', overrides);

      // Toast de chargement simple
      showReservationLoading(
        'Sauvegarde en cours',
        `Application de ${overrides.length} modification${overrides.length > 1 ? 's' : ''}...`
      );

      // Utiliser le hook pour soumettre les surcharges
      submitOverrides(overrides);
    },
    [submitOverrides, showReservationLoading, showReservationInfo]
  );

  // Calculer les √©tats de chargement apr√®s tous les hooks
  const isLoading = isLoadingReservation || isLoadingFields;

  // Fonction pour g√©rer la mise en √©vidence des champs modifi√©s
  const handleHighlightFields = React.useCallback(
    (fieldNames: string[], date: string) => {
      setHighlightedFields(fieldNames);
      setSelectedDate(date);

      // Fermer le dialog apr√®s s√©lection pour voir les champs mis en √©vidence
      setIsHistoryOpen(false);

      // Scroller vers le premier champ mis en √©vidence
      if (fieldNames.length > 0) {
        setTimeout(() => {
          const firstField = document.getElementById(fieldNames[0]);
          if (firstField) {
            firstField.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }, 100);
      }
    },
    []
  );

  // Fonction pour v√©rifier si un champ est mis en √©vidence
  const isFieldHighlighted = React.useCallback(
    (fieldName: string) => {
      return highlightedFields.includes(fieldName);
    },
    [highlightedFields]
  );

  // Cr√©er un mapping des overrides actuels par fieldName
  const currentOverrides = React.useMemo(() => {
    if (!historyData?.data) return {};

    const overridesMap: Record<string, string> = {};
    historyData.data.forEach(override => {
      // Prendre la valeur la plus r√©cente pour chaque champ
      if (
        !overridesMap[override.fieldName] ||
        new Date(override.createdAt) >
          new Date(
            historyData.data.find(o => o.fieldName === override.fieldName)
              ?.createdAt || ''
          )
      ) {
        overridesMap[override.fieldName] = override.overriddenValue;
      }
    });

    return overridesMap;
  }, [historyData]);

  // Fonction pour obtenir la valeur √† afficher dans un champ (override ou valeur originale)
  const getFieldDisplayValue = React.useCallback(
    (fieldName: string) => {
      // Si il y a un override actuel, l'utiliser
      if (currentOverrides[fieldName]) {
        return currentOverrides[fieldName];
      }

      // Sinon, utiliser la valeur de la r√©servation
      return getFieldValue(fieldName, reservation);
    },
    [currentOverrides, reservation]
  );

  // Fonction pour v√©rifier si un champ a un override actuel
  const hasCurrentOverride = React.useCallback(
    (fieldName: string) => {
      return !!currentOverrides[fieldName];
    },
    [currentOverrides]
  );

  // Fonction pour d√©clencher la suppression d'un override
  const handleDeleteOverride = React.useCallback(
    (fieldName: string, displayName: string) => {
      const overriddenValue = currentOverrides[fieldName];
      setFieldToDelete({
        fieldName,
        displayName,
        overriddenValue,
      });
      setDeleteModalOpen(true);
    },
    [currentOverrides]
  );

  // Fonction pour confirmer la suppression
  const confirmDeleteOverride = React.useCallback(() => {
    if (fieldToDelete) {
      deleteOverride(fieldToDelete.fieldName);
    }
  }, [fieldToDelete, deleteOverride]);

  // Gestion des toasts pour la suppression
  React.useEffect(() => {
    if (deleteData?.success) {
      showReservationSuccess(
        'Override supprim√©',
        'La modification a √©t√© supprim√©e avec succ√®s'
      );
      setDeleteModalOpen(false);
      setFieldToDelete(null);

      // Retirer le champ de la mise en √©vidence s'il √©tait mis en √©vidence
      setHighlightedFields(prev =>
        prev.filter(field => field !== fieldToDelete?.fieldName)
      );
    }

    if (deleteError) {
      showReservationError('Erreur de suppression', deleteError.message);
    }
  }, [
    deleteData,
    deleteError,
    fieldToDelete,
    showReservationSuccess,
    showReservationError,
  ]);

  // Fonction pour corriger le type d'inputMode
  const getInputModeFixed = (
    field: any
  ):
    | 'email'
    | 'tel'
    | 'text'
    | 'numeric'
    | 'decimal'
    | 'search'
    | 'none'
    | 'url'
    | undefined => {
    const mode = getInputMode(field);
    if (
      typeof mode === 'string' &&
      [
        'email',
        'tel',
        'text',
        'numeric',
        'decimal',
        'search',
        'none',
        'url',
      ].includes(mode)
    ) {
      return mode as
        | 'email'
        | 'tel'
        | 'text'
        | 'numeric'
        | 'decimal'
        | 'search'
        | 'none'
        | 'url';
    }
    return 'text';
  };

  if (fieldsError) {
    return (
      <DashboardLayout breadcrumbs={breadcrumbs}>
        <div className="flex h-[calc(100vh-200px)] flex-col items-center justify-center gap-6 p-8">
          <div className="flex max-w-md flex-col items-center gap-4 text-center">
            <div className="bg-destructive/10 rounded-full p-4">
              <Loader2 className="text-destructive h-12 w-12" />
            </div>
            <h2 className="text-2xl font-semibold">Erreur</h2>
            <p className="text-muted-foreground">
              Impossible de charger les champs de modification
            </p>
            <Button variant="outline" onClick={() => router.back()}>
              <ArrowLeft className="mr-2 h-4 w-4" />
              Retour
            </Button>
          </div>
        </div>
      </DashboardLayout>
    );
  }

  if (isLoading) {
    return (
      <DashboardLayout breadcrumbs={breadcrumbs}>
        <div className="flex h-[calc(100vh-200px)] flex-col items-center justify-center gap-6 p-8">
          <Loader2 className="h-8 w-8 animate-spin" />
          <p className="text-muted-foreground">Chargement du formulaire...</p>
        </div>
      </DashboardLayout>
    );
  }

  return (
    <DashboardLayout breadcrumbs={breadcrumbs}>
      <div className="container mx-auto py-6">
        {/* Header */}
        <div className="mb-6 flex items-center justify-between">
          <div>
            <h1 className="text-3xl font-bold tracking-tight">
              Modifier la r√©servation
            </h1>
            <p className="text-muted-foreground">
              Code de confirmation: {confirmationCode}
            </p>
            {selectedDate && highlightedFields.length > 0 && (
              <div className="mt-1 flex items-center gap-2">
                <p className="text-sm text-blue-600">
                  üìç {highlightedFields.length} champ
                  {highlightedFields.length > 1 ? 's' : ''} modifi√©
                  {highlightedFields.length > 1 ? 's' : ''} le {selectedDate}
                </p>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => {
                    setHighlightedFields([]);
                    setSelectedDate('');
                  }}
                  className="h-6 px-2 text-xs"
                >
                  Effacer
                </Button>
              </div>
            )}
          </div>
          <div className="flex gap-2">
            <Dialog open={isHistoryOpen} onOpenChange={setIsHistoryOpen}>
              <DialogTrigger asChild>
                <Button variant="outline" disabled={isLoadingHistory}>
                  {isLoadingHistory ? (
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  ) : (
                    <History className="mr-2 h-4 w-4" />
                  )}
                  Historique
                </Button>
              </DialogTrigger>
              <DialogContent className="max-h-[80vh] max-w-2xl">
                <DialogHeader>
                  <DialogTitle>Historique des modifications</DialogTitle>
                </DialogHeader>
                {historyData && (
                  <HistoryTimeline
                    history={(historyData.data as any[]) || []}
                    onHighlightFields={handleHighlightFields}
                  />
                )}
              </DialogContent>
            </Dialog>
            <Button variant="outline" onClick={() => router.back()}>
              <ArrowLeft className="mr-2 h-4 w-4" />
              Retour
            </Button>
          </div>
        </div>

        {/* Formulaire */}
        <form
          onSubmit={handleSubmit(handleFormSubmit, handleFormError)}
          className="space-y-6"
        >
          {Object.entries(groupedFields).map(([category, fields]) => (
            <Card key={category}>
              <CardHeader>
                <CardTitle className="text-lg">{category}</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
                  {(
                    fields as Array<{
                      fieldName: string;
                      displayName: string;
                      type: string;
                    }>
                  ).map(field => (
                    <div
                      key={field.fieldName}
                      className={`space-y-2 transition-all duration-300 ${
                        isFieldHighlighted(field.fieldName)
                          ? 'ring-opacity-50 scale-105 transform rounded-lg bg-blue-50/30 p-2 ring-2 ring-blue-500'
                          : ''
                      }`}
                    >
                      <Label htmlFor={field.fieldName}>
                        {field.displayName}
                        {(field.fieldName === 'guest_email' ||
                          [
                            'number_of_guests',
                            'adults',
                            'children',
                            'infants',
                          ].includes(field.fieldName)) && (
                          <span className="ml-1 text-red-500">*</span>
                        )}
                        {isFieldHighlighted(field.fieldName) && (
                          <span className="ml-2 rounded-full bg-blue-100 px-2 py-1 text-xs text-blue-800">
                            Modifi√©
                          </span>
                        )}
                        {hasCurrentOverride(field.fieldName) && (
                          <Button
                            type="button"
                            variant="ghost"
                            size="sm"
                            className="ml-2 h-6 w-6 p-0 text-red-500 hover:bg-red-50 hover:text-red-700"
                            onClick={() =>
                              handleDeleteOverride(
                                field.fieldName,
                                field.displayName
                              )
                            }
                            title="Supprimer la modification"
                          >
                            ‚úï
                          </Button>
                        )}
                      </Label>
                      <Input
                        id={field.fieldName}
                        type={getInputType(field)}
                        step={
                          field.type === 'number'
                            ? '0.01'
                            : field.type === 'integer'
                              ? '1'
                              : undefined
                        }
                        min={field.type !== 'string' ? '0' : undefined}
                        pattern={getInputPattern(field)}
                        inputMode={getInputModeFixed(field)}
                        {...register(field.fieldName)}
                        placeholder={getPlaceholder(field)}
                        className={
                          isFieldHighlighted(field.fieldName)
                            ? 'border-blue-400 focus:border-blue-500'
                            : ''
                        }
                        defaultValue={getFieldDisplayValue(field.fieldName)}
                        onBlur={e => {
                          // Formater la valeur lors de la perte de focus pour les champs num√©riques
                          if (
                            (field.type === 'number' ||
                              field.type === 'integer') &&
                            e.target.value
                          ) {
                            const formattedValue = formatValueForDisplay(
                              e.target.value,
                              field.type
                            );
                            if (formattedValue !== e.target.value) {
                              e.target.value = formattedValue;
                              // D√©clencher l'√©v√©nement pour que React Hook Form soit au courant
                              e.target.dispatchEvent(
                                new Event('input', { bubbles: true })
                              );
                            }
                          }
                        }}
                      />
                      {errors[field.fieldName] && (
                        <p className="text-destructive text-sm">
                          {errors[field.fieldName]?.message}
                        </p>
                      )}
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
          ))}

          {/* Actions */}
          <div className="flex justify-end gap-4">
            <Button
              type="button"
              variant="outline"
              onClick={() => router.back()}
            >
              Annuler
            </Button>
            <Button type="submit" disabled={isSubmitting}>
              {isSubmitting ? (
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              ) : (
                <Save className="mr-2 h-4 w-4" />
              )}
              {isSubmitting ? 'Enregistrement...' : 'Enregistrer'}
            </Button>
          </div>
        </form>

        {/* Modal de confirmation de suppression */}
        {fieldToDelete && (
          <div>
            <div
              className="fixed inset-0 z-50 bg-black/50"
              onClick={() => setDeleteModalOpen(false)}
            />
            <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
              <div className="w-full max-w-md rounded-lg bg-white p-6 shadow-lg">
                <h3 className="mb-4 text-lg font-semibold">
                  Supprimer la modification
                </h3>
                <p className="mb-4 text-sm text-gray-600">
                  √ätes-vous s√ªr de vouloir supprimer la modification pour le
                  champ "{fieldToDelete.displayName}" ?
                </p>
                <p className="mb-6 text-sm text-gray-500">
                  Valeur actuelle :{' '}
                  <span className="font-mono">
                    {fieldToDelete.overriddenValue}
                  </span>
                </p>
                <div className="flex justify-end gap-2">
                  <Button
                    variant="outline"
                    onClick={() => setDeleteModalOpen(false)}
                    disabled={isDeleting}
                  >
                    Annuler
                  </Button>
                  <Button
                    variant="destructive"
                    onClick={confirmDeleteOverride}
                    disabled={isDeleting}
                  >
                    {isDeleting ? (
                      <>
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                        Suppression...
                      </>
                    ) : (
                      'Supprimer'
                    )}
                  </Button>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    </DashboardLayout>
  );
}
