import {
  Calendar,
  CheckCircle,
  Clock,
  Edit,
  MapPin,
  User,
  XCircle,
} from 'lucide-react';
import React from 'react';

import { Badge } from '@/components/ui/badge';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

import type { ReservationDetails } from '../types/reservation-details';

interface ReservationTimelineProps {
  reservation: ReservationDetails;
}

interface TimelineEvent {
  date: string | null;
  label: string;
  description: string;
  icon: React.ReactNode;
  variant: 'default' | 'success' | 'warning' | 'destructive';
  isPast: boolean;
  isFuture: boolean;
}

export function ReservationTimeline({ reservation }: ReservationTimelineProps) {
  const buildTimeline = (): TimelineEvent[] => {
    const events: TimelineEvent[] = [];
    const now = new Date();

    const getTimeStatus = (dateStr: string | null) => {
      if (!dateStr) return { isPast: false, isFuture: false };
      const date = new Date(dateStr);
      return { isPast: date < now, isFuture: date > now };
    };

    const created = (reservation as unknown as { DTE_CREATE?: string })
      .DTE_CREATE;
    if (created) {
      const status = getTimeStatus(created);
      events.push({
        date: created,
        label: 'Réservation créée',
        description: 'Création initiale de la réservation dans le système',
        icon: <User className="h-4 w-4" />,
        variant: 'default',
        ...status,
      });
    }

    const confirmed =
      (
        reservation as unknown as {
          DTE_CONFIRM?: string;
          confirmed_at?: string;
        }
      ).DTE_CONFIRM ??
      (reservation as unknown as { confirmed_at?: string }).confirmed_at ??
      null;
    if (confirmed) {
      const status = getTimeStatus(confirmed);
      events.push({
        date: confirmed,
        label: 'Réservation confirmée',
        description: 'Confirmation officielle de la réservation',
        icon: <CheckCircle className="h-4 w-4" />,
        variant: 'success',
        ...status,
      });
    }

    const checkin =
      (reservation as unknown as { DTE_CI?: string }).DTE_CI ??
      reservation.checkin_date ??
      (reservation as unknown as { reservation_checkIn?: string })
        .reservation_checkIn ??
      null;
    if (checkin) {
      const status = getTimeStatus(checkin);
      events.push({
        date: checkin,
        label: 'Arrivée (Check-in)',
        description: 'Début du séjour au logement',
        icon: <MapPin className="h-4 w-4" />,
        variant: status.isPast ? 'success' : 'default',
        ...status,
      });
    }

    const checkout =
      (reservation as unknown as { DTE_CO?: string }).DTE_CO ??
      reservation.checkout_date ??
      (reservation as unknown as { reservation_checkOut?: string })
        .reservation_checkOut ??
      null;
    if (checkout) {
      const status = getTimeStatus(checkout);
      events.push({
        date: checkout,
        label: 'Départ (Check-out)',
        description: 'Fin du séjour et libération du logement',
        icon: <MapPin className="h-4 w-4" />,
        variant: status.isPast ? 'success' : 'default',
        ...status,
      });
    }

    const modified = (reservation as unknown as { DTE_MOD?: string }).DTE_MOD;
    if (modified && modified !== created) {
      const status = getTimeStatus(modified);
      events.push({
        date: modified,
        label: 'Dernière modification',
        description: 'Dernière mise à jour des informations de réservation',
        icon: <Edit className="h-4 w-4" />,
        variant: 'default',
        ...status,
      });
    }

    const canceled =
      (
        reservation as unknown as {
          DTE_CANCELED?: string;
          canceled_at?: string;
        }
      ).DTE_CANCELED ??
      (reservation as unknown as { canceled_at?: string }).canceled_at ??
      null;
    if (canceled) {
      const status = getTimeStatus(canceled);
      events.push({
        date: canceled,
        label: 'Réservation annulée',
        description: 'Annulation de la réservation',
        icon: <XCircle className="h-4 w-4" />,
        variant: 'destructive',
        ...status,
      });
    }

    return events
      .filter(e => e.date)
      .sort((a, b) =>
        a.date && b.date
          ? new Date(a.date).getTime() - new Date(b.date).getTime()
          : 0
      );
  };

  const formatDateTime = (dateStr: string) => {
    try {
      const date = new Date(dateStr);
      return {
        date: date.toLocaleDateString('fr-FR', {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric',
        }),
        time: date.toLocaleTimeString('fr-FR', {
          hour: '2-digit',
          minute: '2-digit',
        }),
      };
    } catch {
      return { date: dateStr, time: null as unknown as string };
    }
  };

  const timeline = buildTimeline();
  const checkinDate =
    (reservation as unknown as { DTE_CI?: string }).DTE_CI ??
    reservation.checkin_date ??
    null;
  const checkoutDate =
    (reservation as unknown as { DTE_CO?: string }).DTE_CO ??
    reservation.checkout_date ??
    null;
  const nightsRaw =
    (reservation as unknown as { NUMBER_OF_NIGHTS?: number })
      .NUMBER_OF_NIGHTS ??
    reservation.nights ??
    0;

  const computeNightsFromDates = (
    ci: string | null,
    co: string | null
  ): number => {
    if (!ci || !co) return 0;
    const ciDate = new Date(ci);
    const coDate = new Date(co);
    if (Number.isNaN(ciDate.getTime()) || Number.isNaN(coDate.getTime()))
      return 0;
    const ciUTC = Date.UTC(
      ciDate.getFullYear(),
      ciDate.getMonth(),
      ciDate.getDate()
    );
    const coUTC = Date.UTC(
      coDate.getFullYear(),
      coDate.getMonth(),
      coDate.getDate()
    );
    const diffDays = Math.round((coUTC - ciUTC) / 86_400_000);
    return Math.max(0, diffDays);
  };

  const nights =
    Number.isFinite(nightsRaw) && nightsRaw > 0
      ? Math.round(Number(nightsRaw))
      : computeNightsFromDates(checkinDate, checkoutDate);

  const getVariantClasses = (variant: string) => {
    switch (variant) {
      case 'success':
        return 'text-green-600 dark:text-green-400';
      case 'warning':
        return 'text-yellow-600 dark:text-yellow-400';
      case 'destructive':
        return 'text-red-600 dark:text-red-400';
      default:
        return 'text-blue-600 dark:text-blue-400';
    }
  };

  const getBadgeVariant = (event: TimelineEvent) => {
    if (event.isPast) return 'secondary';
    if (event.isFuture) return 'outline';
    return 'default';
  };

  const getBadgeText = (event: TimelineEvent) => {
    if (event.isPast) return 'Passé';
    if (event.isFuture) return 'À venir';
    return 'En cours';
  };

  return (
    <div className="space-y-6">
      {checkinDate && checkoutDate && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2 text-lg">
              <Calendar className="h-5 w-5" /> Période de séjour
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid gap-4 md:grid-cols-3">
              <div className="flex flex-col gap-1">
                <span className="text-muted-foreground text-sm">Arrivée</span>
                <span className="font-medium">
                  {formatDateTime(checkinDate).date}
                </span>
                <span className="text-muted-foreground text-sm">
                  {formatDateTime(checkinDate).time}
                </span>
              </div>
              <div className="flex flex-col items-center gap-1">
                <span className="text-muted-foreground text-sm">Durée</span>
                <Badge variant="outline" className="text-sm">
                  {nights} nuit{nights > 1 ? 's' : ''}
                </Badge>
              </div>
              <div className="flex flex-col gap-1 md:items-end">
                <span className="text-muted-foreground text-sm">Départ</span>
                <span className="font-medium">
                  {formatDateTime(checkoutDate).date}
                </span>
                <span className="text-muted-foreground text-sm">
                  {formatDateTime(checkoutDate).time}
                </span>
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2 text-lg">
            <Clock className="h-5 w-5" /> Historique des événements
          </CardTitle>
        </CardHeader>
        <CardContent>
          {timeline.length === 0 ? (
            <div className="text-muted-foreground py-8 text-center">
              <Clock className="mx-auto mb-4 h-12 w-12 opacity-50" />
              <p>Aucun événement d&apos;historique disponible</p>
            </div>
          ) : (
            <div className="space-y-6">
              {timeline.map((event, index) => {
                if (!event.date) return null;
                const { date, time } = formatDateTime(event.date);
                return (
                  <div key={index} className="relative">
                    {index < timeline.length - 1 && (
                      <div className="bg-border absolute top-12 left-6 h-6 w-0.5" />
                    )}
                    <div className="flex gap-4">
                      <div
                        className={`flex h-12 w-12 flex-shrink-0 items-center justify-center rounded-full border-2 ${getVariantClasses(event.variant)} bg-background`}
                      >
                        {event.icon}
                      </div>
                      <div className="flex-1 space-y-1">
                        <div className="flex flex-wrap items-center gap-2">
                          <h4 className="font-medium">{event.label}</h4>
                          <span className="text-muted-foreground text-sm font-medium">
                            {date}
                          </span>
                          {time && (
                            <span className="text-muted-foreground text-xs">
                              à {time}
                            </span>
                          )}
                          <Badge
                            variant={getBadgeVariant(event)}
                            className="text-xs"
                          >
                            {getBadgeText(event)}
                          </Badge>
                        </div>
                        <p className="text-muted-foreground text-sm">
                          {event.description}
                        </p>
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
